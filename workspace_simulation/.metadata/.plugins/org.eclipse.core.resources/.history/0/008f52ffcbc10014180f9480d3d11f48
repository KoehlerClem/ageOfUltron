#include "../h/Configuration.h"

void visitPoint();
int pointExists();
void createPoints();
int getArrayAddressFromCoord();
void setNull();
void moveNorth();
void moveEast();
void moveSouth();
void moveWest();

int main(void) {



	/* Hier wird der Struct für einen Point definiert. Der Point hat x,y Coordinaten
	 * in coord gespeichert, einen int Wert für die Kanten und einen bool-Wert des
	 * aussagt ob der Punkt schon besucht wurde!
	 */
	typedef struct points{
		short coord[2];
		int edges;
		int visited;
	} point;

	point allPoints[77];					// Das Array in dem Alle Punkte gespeichert werden
	short currentArrayPoint = 0;			// Der Punkt an dem der letzte Punkt in dem Array erstellt wurde
	short currentCoord[2] = {0,0};			// Die aktuelle Coordinate des aktuellen Punktes

	//Füllt alle Points mit werten auf
	int pointsfiller;
	for ( pointsfiller = 0; pointsfiller < 76; pointsfiller++ ){
		allPoints[pointsfiller].coord[0] = 0;
		allPoints[pointsfiller].coord[1] = 0;
		allPoints[pointsfiller].edges = 0;
		allPoints[pointsfiller].visited = 0;
	}

	/* Wenn ein Punkt besucht wird, werden die Kanten des aktuellen Punktes gespeichert,
	 * er als Besucht markiert und die 4 Umliegenden Punkte erstellt, fals es sie noch nicht gibt!
	*/
	void visitPoint(){

		//Holt die Adresse in dem Array zu den Aktuellen Coordinaten
		int i = getArrayAddressFromCoord(currentCoord);

		allPoints[i].edges = Robot_GetIntersections();
		allPoints[i].visited = 1;

		createPoints(currentCoord[0] + 1,currentCoord[1]);
		createPoints(currentCoord[0] - 1,currentCoord[1]);
		createPoints(currentCoord[0],currentCoord[1] + 1);
		createPoints(currentCoord[0],currentCoord[1] - 1);
	}

	/* Vergleicht zuerst die X-Coordinate des jeweils betrachteten Punktes gegen die übergebene X-Coordinate
	 * und wenn wenn diese Übereistimmt vergleicht die Funktion auch die Y-Coordinate. Wenn diese auch gleich ist
	 * wird true zurückgegeben.
	 */
	int pointExists(short coordToCheck[2]){
		int i;
		for ( i = 0; i < currentArrayPoint + 1; i++ ){
			if ( coordToCheck[0] == allPoints[i].coord[0]){
				if ( coordToCheck[1] == allPoints[i].coord[1]){
					return 1;
				} else {
					return 0;
				};
			} else {
				return 0;
			};
		}
	}

	/* Es wird zuerst überprüft ob an den gegebenen Koordinaten schon ein Punk existiert.
	 * Fals dies nicht der Fall ist wird ein neuer Punkt an den Koordinaten erstellt und
	 * der Wert des current Arrays, also des erzeit vereachteten Punkts zurückgegeben.
	 */
	void createPoints(short x, short y){
		short coord2[2] = {x, y};
		if (pointExists(coord2) == false){

			allPoints[currentArrayPoint + 1].coord[0] = 1;
			allPoints[currentArrayPoint + 1].visited = false;
			currentArrayPoint += 1;

		}


	}

	int getArrayAddressFromCoord(short coordToCheck[2]){
		int i;
		for ( i = 0; i < currentArrayPoint + 1; i++ ){
			if ( coordToCheck[0] == allPoints[i].coord[0]){
				if ( coordToCheck[1] == allPoints[i].coord[1]){
					return i;
				} else {
					return 0;
				}
			} else {
				return 0;
			}
		}
	}


	/* Setzt den Punkt auf 0,0, empfohlen für den Start der Simulation
	 */
	void setNull(){
		Robot_Move(0,0);
		currentCoord[0] = 0;
		currentCoord[1] = 0;
		visitPoint();
	}

	/* Checkt ob eine bewegung nach Oben möglich ist. Wenn sie möglich ist
	 * wird die CurrentCoord auf die neue Coordinate gesetzt und die Funktion
	 * visitPoint() aufgerufen.
	 */

	/* Bewegt den Roboter einen Punkt nach oben bzw erhöht den y-Wert der
	 * Coordinate um 1 wenn möglich
	 */
	void moveNorth(){
		if (currentCoord[1] != 0){
			Robot_Move(currentCoord[0], currentCoord[1] + 1);
			currentCoord[1] = currentCoord[1] + 1;
			visitPoint();
		}
	}

	/* Bewegt den Roboter einen Punkt nach rechts bzw erhöht den x-Wert der
	 * Coordinate um 1 wenn möglich
	 */
	void moveEast(){
		if (currentCoord[0] != 6){
			Robot_Move(currentCoord[0] + 1, currentCoord[1]);
			currentCoord[0] = currentCoord[0] + 1;
			visitPoint();
		}
	}

	/* Bewegt den Roboter einen Punkt nach unten bzw verringert den y-Wert der
	 * Coordinate um 1 wenn möglich
	 */
	void moveSouth(){
		if (currentCoord[1] != -6){
			Robot_Move(currentCoord[0], currentCoord[1] - 1);
			currentCoord[1] = currentCoord[1] - 1;
			visitPoint();
		}
	}

	/* Bewegt den Roboter einen Punkt nach links bzw verringert den x-Wert der
	 * Coordinate um 1 wenn möglich
	 */
	void moveWest(){
		if (currentCoord[0] != 0){
			Robot_Move(currentCoord[0] - 1, currentCoord[1]);
			currentCoord[0] = currentCoord[0] - 1;
			visitPoint();
		}
	}






	printf("Token: %d\n", Robot_Move(0, 0));
	printf("Intersection: %d\n", Robot_GetIntersections());
	printf("Token: %d\n", Robot_Move(1, 0));
	printf("Intersection: %d\n", Robot_GetIntersections());
	printf("Token: %d\n", Robot_Move(2, 0));

	return EXIT_SUCCESS;
}
